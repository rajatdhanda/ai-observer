import * as fs from 'fs';
import * as path from 'path';
import { FrameworkDetector } from './framework-detector';
import { TypeExtractor } from './type-extractor';
import { DataFlowMapper } from './data-flow-mapper';
import { EntityIdentifier } from './entity-identifier';
import { ValidationRuleGenerator } from './rule-generator';

export interface ProjectAnalysis {
  projectPath: string;
  projectName: string;
  framework: FrameworkInfo;
  types: TypeSystem;
  dataFlow: DataFlowMap;
  entities: BusinessEntity[];
  validationRules: ValidationRule[];
  timestamp: string;
}

export interface FrameworkInfo {
  name: string;
  version: string;
  type: 'frontend' | 'backend' | 'fullstack';
  dependencies: Record<string, string>;
  scripts: Record<string, string>;
}

export interface TypeSystem {
  interfaces: TypeDefinition[];
  types: TypeDefinition[];
  enums: TypeDefinition[];
  totalCount: number;
  files: string[];
}

export interface TypeDefinition {
  name: string;
  filePath: string;
  properties?: PropertyDefinition[];
  category?: 'database' | 'api' | 'component' | 'state' | 'utility';
}

export interface PropertyDefinition {
  name: string;
  type: string;
  required: boolean;
  description?: string;
}

export interface DataFlowMap {
  layers: Layer[];
  connections: Connection[];
  criticalPaths: CriticalPath[];
}

export interface Layer {
  name: string;
  type: 'database' | 'api' | 'state' | 'ui';
  components: string[];
}

export interface Connection {
  from: string;
  to: string;
  dataType: string;
  method?: string;
}

export interface CriticalPath {
  name: string;
  steps: string[];
  importance: 'high' | 'medium' | 'low';
}

export interface BusinessEntity {
  name: string;
  type: string;
  properties: PropertyDefinition[];
  relationships: Relationship[];
  operations: string[];
}

export interface Relationship {
  type: 'hasOne' | 'hasMany' | 'belongsTo' | 'manyToMany';
  entity: string;
  foreign_key?: string;
}

export interface ValidationRule {
  id: string;
  name: string;
  type: 'type' | 'business' | 'performance' | 'security';
  severity: 'error' | 'warning' | 'info';
  path: string;
  rule: string;
  autoGenerated: boolean;
}

export class ProjectAnalyzer {
  private frameworkDetector: FrameworkDetector;
  private typeExtractor: TypeExtractor;
  private dataFlowMapper: DataFlowMapper;
  private entityIdentifier: EntityIdentifier;
  private ruleGenerator: ValidationRuleGenerator;

  constructor() {
    this.frameworkDetector = new FrameworkDetector();
    this.typeExtractor = new TypeExtractor();
    this.dataFlowMapper = new DataFlowMapper();
    this.entityIdentifier = new EntityIdentifier();
    this.ruleGenerator = new ValidationRuleGenerator();
  }

  async analyze(projectPath: string): Promise<ProjectAnalysis> {
    console.log(`üîç Analyzing project: ${projectPath}`);
    
    // Validate project path
    if (!fs.existsSync(projectPath)) {
      throw new Error(`Project path does not exist: ${projectPath}`);
    }

    const projectName = path.basename(projectPath);
    
    // Step 1: Detect framework and dependencies
    console.log('üì¶ Detecting framework...');
    const framework = await this.frameworkDetector.detect(projectPath);
    
    // Step 2: Extract type system
    console.log('üî§ Extracting types...');
    const types = await this.typeExtractor.extract(projectPath);
    
    // Step 3: Map data flow
    console.log('üîÑ Mapping data flow...');
    const dataFlow = await this.dataFlowMapper.map(projectPath, types);
    
    // Step 4: Identify business entities
    console.log('üè¢ Identifying business entities...');
    const entities = await this.entityIdentifier.identify(types, dataFlow);
    
    // Step 5: Generate validation rules
    console.log('‚úÖ Generating validation rules...');
    const validationRules = await this.ruleGenerator.generate(types, entities, dataFlow);
    
    const analysis: ProjectAnalysis = {
      projectPath,
      projectName,
      framework,
      types,
      dataFlow,
      entities,
      validationRules,
      timestamp: new Date().toISOString()
    };

    // Save analysis to file
    this.saveAnalysis(analysis);
    
    console.log('‚ú® Analysis complete!');
    return analysis;
  }

  private saveAnalysis(analysis: ProjectAnalysis): void {
    const outputDir = path.join(process.cwd(), '.observer');
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }
    
    const outputPath = path.join(outputDir, 'analysis.json');
    fs.writeFileSync(outputPath, JSON.stringify(analysis, null, 2));
    console.log(`üíæ Analysis saved to: ${outputPath}`);
  }

  async watch(projectPath: string): Promise<void> {
    // Initial analysis
    await this.analyze(projectPath);
    
    // Set up file watcher for real-time updates
    console.log('üëÅÔ∏è Watching for changes...');
    
    fs.watch(projectPath, { recursive: true }, async (eventType, filename) => {
      if (filename && this.shouldAnalyzeFile(filename)) {
        console.log(`üîÑ Change detected in ${filename}`);
        // Incremental analysis could be implemented here
        await this.analyze(projectPath);
      }
    });
  }

  private shouldAnalyzeFile(filename: string): boolean {
    const extensions = ['.ts', '.tsx', '.js', '.jsx', '.json'];
    const excludes = ['node_modules', '.next', 'dist', 'build', '.git'];
    
    return extensions.some(ext => filename.endsWith(ext)) &&
           !excludes.some(exclude => filename.includes(exclude));
  }
}