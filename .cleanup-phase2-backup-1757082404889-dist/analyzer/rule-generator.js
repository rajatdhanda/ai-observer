"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidationRuleGenerator = void 0;
class ValidationRuleGenerator {
    ruleCounter = 0;
    async generate(types, entities, dataFlow) {
        const rules = [];
        // Generate type validation rules
        rules.push(...this.generateTypeRules(types));
        // Generate business logic rules
        rules.push(...this.generateBusinessRules(entities));
        // Generate data flow rules
        rules.push(...this.generateDataFlowRules(dataFlow));
        // Generate performance rules
        rules.push(...this.generatePerformanceRules(entities));
        // Generate security rules
        rules.push(...this.generateSecurityRules(entities, types));
        return rules;
    }
    generateTypeRules(types) {
        const rules = [];
        // Required field validation
        for (const iface of types.interfaces) {
            if (iface.properties) {
                for (const prop of iface.properties) {
                    if (prop.required) {
                        rules.push({
                            id: this.generateRuleId(),
                            name: `${iface.name}.${prop.name} is required`,
                            type: 'type',
                            severity: 'error',
                            path: `${iface.name}.${prop.name}`,
                            rule: `${prop.name} !== null && ${prop.name} !== undefined`,
                            autoGenerated: true
                        });
                    }
                    // Type checking rules
                    if (prop.type === 'string') {
                        rules.push({
                            id: this.generateRuleId(),
                            name: `${iface.name}.${prop.name} must be string`,
                            type: 'type',
                            severity: 'error',
                            path: `${iface.name}.${prop.name}`,
                            rule: `typeof ${prop.name} === 'string'`,
                            autoGenerated: true
                        });
                    }
                    else if (prop.type === 'number') {
                        rules.push({
                            id: this.generateRuleId(),
                            name: `${iface.name}.${prop.name} must be number`,
                            type: 'type',
                            severity: 'error',
                            path: `${iface.name}.${prop.name}`,
                            rule: `typeof ${prop.name} === 'number'`,
                            autoGenerated: true
                        });
                    }
                    else if (prop.type === 'boolean') {
                        rules.push({
                            id: this.generateRuleId(),
                            name: `${iface.name}.${prop.name} must be boolean`,
                            type: 'type',
                            severity: 'error',
                            path: `${iface.name}.${prop.name}`,
                            rule: `typeof ${prop.name} === 'boolean'`,
                            autoGenerated: true
                        });
                    }
                }
            }
        }
        return rules;
    }
    generateBusinessRules(entities) {
        const rules = [];
        for (const entity of entities) {
            // Email validation
            const emailProp = entity.properties.find(p => p.name.toLowerCase().includes('email'));
            if (emailProp) {
                rules.push({
                    id: this.generateRuleId(),
                    name: `${entity.name}.${emailProp.name} must be valid email`,
                    type: 'business',
                    severity: 'error',
                    path: `${entity.name}.${emailProp.name}`,
                    rule: `/^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$/.test(${emailProp.name})`,
                    autoGenerated: true
                });
            }
            // Phone validation
            const phoneProp = entity.properties.find(p => p.name.toLowerCase().includes('phone'));
            if (phoneProp) {
                rules.push({
                    id: this.generateRuleId(),
                    name: `${entity.name}.${phoneProp.name} must be valid phone`,
                    type: 'business',
                    severity: 'warning',
                    path: `${entity.name}.${phoneProp.name}`,
                    rule: `/^[\\+]?[(]?[0-9]{3}[)]?[-\\s\\.]?[0-9]{3}[-\\s\\.]?[0-9]{4,6}$/.test(${phoneProp.name})`,
                    autoGenerated: true
                });
            }
            // Date validation
            const dateProp = entity.properties.find(p => p.name.toLowerCase().includes('date') ||
                p.name.toLowerCase().includes('_at'));
            if (dateProp) {
                rules.push({
                    id: this.generateRuleId(),
                    name: `${entity.name}.${dateProp.name} must be valid date`,
                    type: 'business',
                    severity: 'error',
                    path: `${entity.name}.${dateProp.name}`,
                    rule: `!isNaN(new Date(${dateProp.name}).getTime())`,
                    autoGenerated: true
                });
            }
            // Price/Amount validation
            const priceProp = entity.properties.find(p => p.name.toLowerCase().includes('price') ||
                p.name.toLowerCase().includes('amount') ||
                p.name.toLowerCase().includes('cost'));
            if (priceProp) {
                rules.push({
                    id: this.generateRuleId(),
                    name: `${entity.name}.${priceProp.name} must be positive`,
                    type: 'business',
                    severity: 'error',
                    path: `${entity.name}.${priceProp.name}`,
                    rule: `${priceProp.name} >= 0`,
                    autoGenerated: true
                });
            }
            // Status validation
            const statusProp = entity.properties.find(p => p.name.toLowerCase().includes('status'));
            if (statusProp) {
                rules.push({
                    id: this.generateRuleId(),
                    name: `${entity.name}.${statusProp.name} must be valid status`,
                    type: 'business',
                    severity: 'error',
                    path: `${entity.name}.${statusProp.name}`,
                    rule: `['active', 'inactive', 'pending', 'completed', 'cancelled'].includes(${statusProp.name})`,
                    autoGenerated: true
                });
            }
        }
        return rules;
    }
    generateDataFlowRules(dataFlow) {
        const rules = [];
        // API response validation
        const apiLayer = dataFlow.layers.find(l => l.type === 'api');
        if (apiLayer) {
            rules.push({
                id: this.generateRuleId(),
                name: 'API responses must have status code',
                type: 'type',
                severity: 'error',
                path: 'api.response',
                rule: 'response.status !== undefined',
                autoGenerated: true
            });
            rules.push({
                id: this.generateRuleId(),
                name: 'API errors must have message',
                type: 'type',
                severity: 'error',
                path: 'api.error',
                rule: 'error.message !== undefined',
                autoGenerated: true
            });
        }
        // Database query validation
        const dbLayer = dataFlow.layers.find(l => l.type === 'database');
        if (dbLayer) {
            rules.push({
                id: this.generateRuleId(),
                name: 'Database queries must have valid ID',
                type: 'business',
                severity: 'error',
                path: 'database.query',
                rule: 'id !== null && id !== undefined',
                autoGenerated: true
            });
        }
        return rules;
    }
    generatePerformanceRules(entities) {
        const rules = [];
        // Large list pagination
        for (const entity of entities) {
            if (entity.operations.includes(`list${entity.name}s`)) {
                rules.push({
                    id: this.generateRuleId(),
                    name: `${entity.name} lists should be paginated`,
                    type: 'performance',
                    severity: 'warning',
                    path: `${entity.name}.list`,
                    rule: 'limit <= 100',
                    autoGenerated: true
                });
            }
        }
        // Image optimization
        rules.push({
            id: this.generateRuleId(),
            name: 'Images should be optimized',
            type: 'performance',
            severity: 'info',
            path: 'assets.images',
            rule: 'fileSize < 1048576', // 1MB
            autoGenerated: true
        });
        // Bundle size
        rules.push({
            id: this.generateRuleId(),
            name: 'Bundle size should be optimal',
            type: 'performance',
            severity: 'warning',
            path: 'build.bundle',
            rule: 'bundleSize < 5242880', // 5MB
            autoGenerated: true
        });
        return rules;
    }
    generateSecurityRules(entities, types) {
        const rules = [];
        // Password validation
        for (const entity of entities) {
            const passwordProp = entity.properties.find(p => p.name.toLowerCase().includes('password'));
            if (passwordProp) {
                rules.push({
                    id: this.generateRuleId(),
                    name: `${entity.name}.password must be strong`,
                    type: 'security',
                    severity: 'error',
                    path: `${entity.name}.${passwordProp.name}`,
                    rule: `${passwordProp.name}.length >= 8 && /[A-Z]/.test(${passwordProp.name}) && /[a-z]/.test(${passwordProp.name}) && /[0-9]/.test(${passwordProp.name})`,
                    autoGenerated: true
                });
                rules.push({
                    id: this.generateRuleId(),
                    name: `${entity.name}.password must be hashed`,
                    type: 'security',
                    severity: 'error',
                    path: `${entity.name}.${passwordProp.name}`,
                    rule: `!${passwordProp.name}.startsWith('$2b$') || !${passwordProp.name}.startsWith('$argon2')`,
                    autoGenerated: true
                });
            }
        }
        // SQL injection prevention
        rules.push({
            id: this.generateRuleId(),
            name: 'Prevent SQL injection',
            type: 'security',
            severity: 'error',
            path: 'database.query',
            rule: `!query.includes('DROP') && !query.includes('DELETE FROM') && !query.includes('--')`,
            autoGenerated: true
        });
        // XSS prevention
        rules.push({
            id: this.generateRuleId(),
            name: 'Prevent XSS attacks',
            type: 'security',
            severity: 'error',
            path: 'ui.render',
            rule: `!content.includes('<script>') && !content.includes('javascript:')`,
            autoGenerated: true
        });
        // Authentication check
        const userEntity = entities.find(e => e.type === 'user');
        if (userEntity) {
            rules.push({
                id: this.generateRuleId(),
                name: 'Protected routes require authentication',
                type: 'security',
                severity: 'error',
                path: 'auth.protected',
                rule: 'user.isAuthenticated === true',
                autoGenerated: true
            });
        }
        return rules;
    }
    generateRuleId() {
        return `rule_${++this.ruleCounter}_${Date.now()}`;
    }
}
exports.ValidationRuleGenerator = ValidationRuleGenerator;
