#!/usr/bin/env node

const chokidar = require('chokidar');
const { execSync } = require('child_process');
const path = require('path');
const fs = require('fs');
const crypto = require('crypto');

// Try to import RemoteLogger if available
let logger;
try {
  const { RemoteLogger } = require('../dist/utils/remote-logger');
  logger = RemoteLogger.getInstance();
} catch {
  // Fallback to console logging if RemoteLogger not available
  logger = {
    info: (msg, src) => console.log(`[${src || 'observer'}] ${msg}`),
    success: (msg, src) => console.log(`âœ… [${src || 'observer'}] ${msg}`),
    warning: (msg, src) => console.log(`âš ï¸ [${src || 'observer'}] ${msg}`),
    error: (msg, src) => console.error(`âŒ [${src || 'observer'}] ${msg}`),
    debug: (msg, src) => console.log(`ðŸ” [${src || 'observer'}] ${msg}`)
  };
}

const projectPath = process.cwd();
const observerDir = path.join(projectPath, '.observer');

// State management
let fileFingerprints = new Map(); // file â†’ {mtime, size, hash}
let analysisInProgress = false;
let pendingAnalysis = false;
let lastAnalysisTime = 0;
let checkCount = 0;

// Configuration
const DEBOUNCE_MS = 200;
const MIN_ANALYSIS_INTERVAL = 3000; // Don't run analysis more than every 3 seconds
const USE_REALTIME = process.argv.includes('--realtime') || process.argv.includes('-r');
const INTERVAL_MODE = !USE_REALTIME;
const CHECK_INTERVAL = 30000; // 30 seconds for interval mode

// Create observer directory
if (!fs.existsSync(observerDir)) {
  fs.mkdirSync(observerDir, { recursive: true });
}

// Clear console and show header
console.clear();
console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
console.log('â•‘              ðŸ¤– AI OBSERVER v2.0 (Production)             â•‘');
console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
console.log(`â•‘ ðŸ“ Project: ${projectPath.padEnd(47)} â•‘`);
console.log(`â•‘ ðŸš€ Mode:    ${(USE_REALTIME ? 'Real-time file watching' : 'Interval checking (30s)').padEnd(47)} â•‘`);
console.log('â•‘ ðŸ“„ Output:  .observer/FIX_THIS.json                       â•‘');
console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
console.log('');

// Debounce function
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// Get file fingerprint (mtime and size)
function getFileFingerprint(filePath) {
  try {
    const stats = fs.statSync(filePath);
    return {
      mtime: stats.mtime.getTime(),
      size: stats.size
    };
  } catch {
    return null;
  }
}

// Get file hash (MD5)
function getFileHash(filePath) {
  try {
    const content = fs.readFileSync(filePath);
    return crypto.createHash('md5').update(content).digest('hex');
  } catch {
    return null;
  }
}

// Check if file actually changed
function hasFileChanged(filePath) {
  const oldFingerprint = fileFingerprints.get(filePath);
  const newFingerprint = getFileFingerprint(filePath);
  
  if (!newFingerprint) return false;
  if (!oldFingerprint) return true;
  
  // Fast path: check mtime and size first
  if (oldFingerprint.mtime === newFingerprint.mtime && 
      oldFingerprint.size === newFingerprint.size) {
    return false;
  }
  
  // Slow path: compute hash only if mtime/size changed
  const newHash = getFileHash(filePath);
  if (oldFingerprint.hash === newHash) {
    // Update mtime/size but keep same hash
    fileFingerprints.set(filePath, { ...newFingerprint, hash: newHash });
    return false;
  }
  
  // File actually changed
  fileFingerprints.set(filePath, { ...newFingerprint, hash: newHash });
  return true;
}

// Analysis function
async function analyze() {
  const now = Date.now();
  
  // Rate limiting in real-time mode
  if (USE_REALTIME && now - lastAnalysisTime < MIN_ANALYSIS_INTERVAL) {
    pendingAnalysis = true;
    setTimeout(() => {
      if (pendingAnalysis) {
        pendingAnalysis = false;
        analyze();
      }
    }, MIN_ANALYSIS_INTERVAL - (now - lastAnalysisTime));
    return;
  }
  
  if (analysisInProgress) {
    pendingAnalysis = true;
    return;
  }
  
  analysisInProgress = true;
  lastAnalysisTime = now;
  checkCount++;
  const startTime = Date.now();
  
  process.stdout.write(`[${new Date().toLocaleTimeString()}] Analyzing... `);
  logger.info('Running analysis...', 'analyzer');
  
  try {
    const issues = [];
    
    // 1. Check contracts
    if (!fs.existsSync(path.join(observerDir, 'contracts.json'))) {
      issues.push({
        file: '.observer/contracts.json:0',
        issue: 'No contracts defined',
        fix: 'Create contracts.json'
      });
      logger.warning('No contracts defined', 'analyzer');
    }
    
    // 2. Run TypeScript check (incremental)
    if (fs.existsSync(path.join(projectPath, 'tsconfig.json'))) {
      try {
        execSync('npx tsc --noEmit --incremental', { 
          cwd: projectPath, 
          stdio: 'pipe',
          timeout: 15000 
        });
      } catch (e) {
        const output = e.stdout?.toString() || '';
        const lines = output.split('\n').slice(0, 20);
        
        lines.forEach(line => {
          const match = line.match(/(.+)\((\d+),\d+\):\s+error\s+TS\d+:\s+(.+)/);
          if (match) {
            issues.push({
              file: `${match[1].replace(projectPath + '/', '')}:${match[2]}`,
              issue: match[3].trim(),
              fix: 'Fix TypeScript error'
            });
          }
        });
      }
    }
    
    // Group issues
    const groups = [];
    if (issues.length > 0) {
      const critical = issues.filter(i => i.file.includes('contracts') || i.file.includes('.env'));
      if (critical.length > 0) {
        groups.push({
          group: 1,
          title: 'Critical setup issues',
          why: 'Must fix before anything else',
          fixes: critical
        });
      }
      
      const tsErrors = issues.filter(i => !critical.includes(i));
      if (tsErrors.length > 0) {
        groups.push({
          group: groups.length + 1,
          title: 'TypeScript errors',
          why: 'Code won\'t build',
          fixes: tsErrors.slice(0, 10)
        });
      }
    }
    
    // Write FIX_THIS.json
    const fixPath = path.join(observerDir, 'FIX_THIS.json');
    const data = {
      README: USE_REALTIME ? "Real-time updates. AI should read this file regularly." : "Auto-updates every 30 seconds.",
      generated: new Date().toISOString(),
      project: projectPath,
      fix_groups: groups,
      stats: {
        total_issues: issues.length,
        groups_count: groups.length,
        mode: USE_REALTIME ? 'real-time' : 'interval',
        check_count: checkCount
      }
    };
    
    fs.writeFileSync(fixPath, JSON.stringify(data, null, 2));
    
    const duration = Date.now() - startTime;
    
    if (issues.length > 0) {
      console.log(`âœ… Found ${issues.length} issues (${groups.length} groups) [${duration}ms]`);
      logger.success(`Found ${issues.length} issues in ${groups.length} groups`, 'analyzer', { duration, issueCount: issues.length });
      groups.forEach(g => {
        console.log(`   â””â”€ Group ${g.group}: ${g.fixes.length} ${g.title.toLowerCase()}`);
      });
    } else {
      console.log(`âœ¨ No issues found! [${duration}ms]`);
      logger.success('No issues found!', 'analyzer', { duration });
    }
  } catch (error) {
    console.log(`âŒ Error: ${error.message}`);
    logger.error(`Analysis failed: ${error.message}`, 'analyzer');
  } finally {
    analysisInProgress = false;
    
    if (pendingAnalysis) {
      pendingAnalysis = false;
      setTimeout(analyze, 100);
    }
  }
}

// Debounced analysis
const debouncedAnalyze = debounce(analyze, DEBOUNCE_MS);

if (USE_REALTIME) {
  // Real-time mode with file watching
  console.log('ðŸ“Š LIVE STATUS:');
  console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
  
  // Set up file watcher
  const watcher = chokidar.watch(['src/**/*.{ts,tsx,js,jsx}', '.env', 'package.json'], {
    ignored: [
      '**/node_modules/**',
      '**/.git/**',
      '**/.observer/**',
      '**/dist/**',
      '**/build/**',
      '**/*.log'
    ],
    persistent: true,
    cwd: projectPath,
    ignoreInitial: true,
    awaitWriteFinish: {
      stabilityThreshold: 100,
      pollInterval: 100
    }
  });

  // Handle file changes
  watcher
    .on('add', filePath => {
      console.log(`ðŸ“ File added: ${filePath}`);
      logger.info(`File added: ${filePath}`, 'watcher');
      debouncedAnalyze();
    })
    .on('change', filePath => {
      if (hasFileChanged(path.join(projectPath, filePath))) {
        console.log(`ðŸ“ File changed: ${filePath}`);
        logger.info(`File changed: ${filePath}`, 'watcher');
        debouncedAnalyze();
      } else {
        process.stdout.write(`[${new Date().toLocaleTimeString()}] Skip: ${filePath} (unchanged)\r`);
        logger.debug(`File unchanged, skipping: ${filePath}`, 'watcher');
      }
    })
    .on('unlink', filePath => {
      console.log(`ðŸ—‘ï¸  File removed: ${filePath}`);
      logger.warning(`File removed: ${filePath}`, 'watcher');
      fileFingerprints.delete(filePath);
      debouncedAnalyze();
    })
    .on('error', error => {
      console.error(`âŒ Watcher error: ${error}`);
      logger.error(`Watcher error: ${error.message}`, 'watcher');
    })
    .on('ready', () => {
      console.log('âœ… Real-time monitoring active\n');
      logger.info(`Started real-time monitoring`, 'watcher');
      // Initial analysis
      analyze();
    });
} else {
  // Interval mode (default)
  console.log('ðŸ“Š LIVE STATUS:');
  console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
  console.log('');
  
  // Initial analysis
  analyze();
  
  // Re-analyze every 30 seconds
  setInterval(analyze, CHECK_INTERVAL);
  
  console.log(`â° Checking every ${CHECK_INTERVAL/1000} seconds`);
  console.log('ðŸ’¡ Tip: Use --realtime or -r flag for real-time file watching\n');
}

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('\n\nðŸ‘‹ Shutting down observer...');
  logger.info('Observer shutdown', 'system');
  if (USE_REALTIME && global.watcher) {
    global.watcher.close();
  }
  process.exit(0);
});

// Keep process alive
process.stdin.resume();