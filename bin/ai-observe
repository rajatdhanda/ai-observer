#!/usr/bin/env node

const chokidar = require('chokidar');
const { execSync } = require('child_process');
const path = require('path');
const fs = require('fs');
const crypto = require('crypto');

// Try to import RemoteLogger if available
let logger;
try {
  const { RemoteLogger } = require('../dist/utils/remote-logger');
  logger = RemoteLogger.getInstance();
} catch {
  // Fallback to console logging if RemoteLogger not available
  logger = {
    info: (msg, src) => console.log(`[${src || 'observer'}] ${msg}`),
    success: (msg, src) => console.log(`✅ [${src || 'observer'}] ${msg}`),
    warning: (msg, src) => console.log(`⚠️ [${src || 'observer'}] ${msg}`),
    error: (msg, src) => console.error(`❌ [${src || 'observer'}] ${msg}`),
    debug: (msg, src) => console.log(`🔍 [${src || 'observer'}] ${msg}`)
  };
}

const projectPath = process.cwd();
const observerDir = path.join(projectPath, '.observer');

// State management
let fileFingerprints = new Map(); // file → {mtime, size, hash}
let analysisInProgress = false;
let pendingAnalysis = false;
let lastAnalysisTime = 0;
let checkCount = 0;

// Configuration
const DEBOUNCE_MS = 200;
const MIN_ANALYSIS_INTERVAL = 3000; // Don't run analysis more than every 3 seconds
const USE_REALTIME = false; // Disabled - too heavy on system
const INTERVAL_MODE = true; // Always use interval mode
const CHECK_INTERVAL = 300000; // 5 minutes for interval mode

// Create observer directory
if (!fs.existsSync(observerDir)) {
  fs.mkdirSync(observerDir, { recursive: true });
}

// Clear console and show header
console.clear();
console.log('╔════════════════════════════════════════════════════════════╗');
console.log('║              🤖 AI OBSERVER v2.0 (Production)             ║');
console.log('╠════════════════════════════════════════════════════════════╣');
console.log(`║ 📁 Project: ${projectPath.padEnd(47)} ║`);
console.log('║ 🚀 Mode:    Interval checking (5 minutes)                 ║');
console.log('║ 📄 Output:  src/contracts/fixes.json                      ║');
console.log('╚════════════════════════════════════════════════════════════╝');
console.log('');

// Debounce function
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// Get file fingerprint (mtime and size)
function getFileFingerprint(filePath) {
  try {
    const stats = fs.statSync(filePath);
    return {
      mtime: stats.mtime.getTime(),
      size: stats.size
    };
  } catch {
    return null;
  }
}

// Get file hash (MD5)
function getFileHash(filePath) {
  try {
    const content = fs.readFileSync(filePath);
    return crypto.createHash('md5').update(content).digest('hex');
  } catch {
    return null;
  }
}

// Check if file actually changed
function hasFileChanged(filePath) {
  const oldFingerprint = fileFingerprints.get(filePath);
  const newFingerprint = getFileFingerprint(filePath);
  
  if (!newFingerprint) return false;
  if (!oldFingerprint) return true;
  
  // Fast path: check mtime and size first
  if (oldFingerprint.mtime === newFingerprint.mtime && 
      oldFingerprint.size === newFingerprint.size) {
    return false;
  }
  
  // Slow path: compute hash only if mtime/size changed
  const newHash = getFileHash(filePath);
  if (oldFingerprint.hash === newHash) {
    // Update mtime/size but keep same hash
    fileFingerprints.set(filePath, { ...newFingerprint, hash: newHash });
    return false;
  }
  
  // File actually changed
  fileFingerprints.set(filePath, { ...newFingerprint, hash: newHash });
  return true;
}

// Analysis function - uses smart analyzer logic
async function analyze() {
  const now = Date.now();
  
  // Rate limiting in real-time mode
  if (USE_REALTIME && now - lastAnalysisTime < MIN_ANALYSIS_INTERVAL) {
    pendingAnalysis = true;
    setTimeout(() => {
      if (pendingAnalysis) {
        pendingAnalysis = false;
        analyze();
      }
    }, MIN_ANALYSIS_INTERVAL - (now - lastAnalysisTime));
    return;
  }
  
  if (analysisInProgress) {
    pendingAnalysis = true;
    return;
  }
  
  analysisInProgress = true;
  lastAnalysisTime = now;
  checkCount++;
  const startTime = Date.now();
  
  process.stdout.write(`[${new Date().toLocaleTimeString()}] Analyzing... `);
  logger.info('Running analysis...', 'analyzer');
  
  try {
    // Run the smart analyzer - it creates src/contracts/fixes.json
    const smartAnalyzerPath = path.join(__dirname, '..', 'dist', 'cli', 'analyze-smart.js');
    const smartResult = execSync(`node "${smartAnalyzerPath}"`, {
      cwd: projectPath,
      stdio: 'pipe',
      timeout: 30000,
      env: { ...process.env, OBSERVER_PROJECT_PATH: projectPath }
    }).toString();
    
    // Read the fixes.json from src/contracts to get issue count for logging
    const contractsDir = path.join(projectPath, 'src', 'contracts');
    const fixesPath = path.join(contractsDir, 'fixes.json');
    
    let totalIssues = 0;
    let bucketsCount = 0;
    
    if (fs.existsSync(fixesPath)) {
      const smartData = JSON.parse(fs.readFileSync(fixesPath, 'utf8'));
      if (smartData.stats) {
        totalIssues = smartData.stats.total_issues_found || 0;
        bucketsCount = smartData.stats.buckets_total || 0;
      }
    }
    
    const duration = Date.now() - startTime;
    
    if (totalIssues > 0) {
      console.log(`✅ Found ${totalIssues} issues in ${bucketsCount} buckets [${duration}ms]`);
      logger.success(`Found ${totalIssues} issues in ${bucketsCount} buckets`, 'analyzer', { duration, issueCount: totalIssues });
      console.log(`   📁 Check src/contracts/fixes.json for details`);
    } else {
      console.log(`✨ No issues found! [${duration}ms]`);
      logger.success('No issues found!', 'analyzer', { duration });
    }
  } catch (error) {
    console.log(`❌ Error: ${error.message}`);
    logger.error(`Analysis failed: ${error.message}`, 'analyzer');
  } finally {
    analysisInProgress = false;
    
    if (pendingAnalysis) {
      pendingAnalysis = false;
      setTimeout(analyze, 100);
    }
  }
}

// Debounced analysis
const debouncedAnalyze = debounce(analyze, DEBOUNCE_MS);

// Interval mode only - no file watching
console.log('📊 LIVE STATUS:');
console.log('────────────────────────────────────────────────────────');
console.log('');

// Initial analysis
analyze();

// Re-analyze every 5 minutes
setInterval(analyze, CHECK_INTERVAL);

console.log(`⏰ Checking every ${CHECK_INTERVAL/1000/60} minutes`);
console.log('💡 Tip: Run without --watch for one-time analysis\n');

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('\n\n👋 Shutting down observer...');
  logger.info('Observer shutdown', 'system');
  if (USE_REALTIME && global.watcher) {
    global.watcher.close();
  }
  process.exit(0);
});

// Keep process alive
process.stdin.resume();