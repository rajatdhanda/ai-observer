#!/usr/bin/env node

const chokidar = require('chokidar');
const { execSync } = require('child_process');
const path = require('path');
const fs = require('fs');
const crypto = require('crypto');

// Try to import RemoteLogger if available
let logger;
try {
  const { RemoteLogger } = require('../dist/utils/remote-logger');
  logger = RemoteLogger.getInstance();
} catch {
  // Fallback to console logging if RemoteLogger not available
  logger = {
    info: (msg, src) => console.log(`[${src || 'observer'}] ${msg}`),
    success: (msg, src) => console.log(`âœ… [${src || 'observer'}] ${msg}`),
    warning: (msg, src) => console.log(`âš ï¸ [${src || 'observer'}] ${msg}`),
    error: (msg, src) => console.error(`âŒ [${src || 'observer'}] ${msg}`),
    debug: (msg, src) => console.log(`ðŸ” [${src || 'observer'}] ${msg}`)
  };
}

const projectPath = process.cwd();
const observerDir = path.join(projectPath, '.observer');

// State management
let fileFingerprints = new Map(); // file â†’ {mtime, size, hash}
let analysisInProgress = false;
let pendingAnalysis = false;
let lastAnalysisTime = 0;
let checkCount = 0;

// Configuration
const DEBOUNCE_MS = 200;
const MIN_ANALYSIS_INTERVAL = 3000; // Don't run analysis more than every 3 seconds
const USE_REALTIME = process.argv.includes('--realtime') || process.argv.includes('-r');
const INTERVAL_MODE = !USE_REALTIME;
const CHECK_INTERVAL = 30000; // 30 seconds for interval mode

// Create observer directory
if (!fs.existsSync(observerDir)) {
  fs.mkdirSync(observerDir, { recursive: true });
}

// Clear console and show header
console.clear();
console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
console.log('â•‘              ðŸ¤– AI OBSERVER v2.0 (Production)             â•‘');
console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
console.log(`â•‘ ðŸ“ Project: ${projectPath.padEnd(47)} â•‘`);
console.log(`â•‘ ðŸš€ Mode:    ${(USE_REALTIME ? 'Real-time file watching' : 'Interval checking (30s)').padEnd(47)} â•‘`);
console.log('â•‘ ðŸ“„ Output:  .observer/FIX_THIS.json                       â•‘');
console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
console.log('');

// Debounce function
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// Get file fingerprint (mtime and size)
function getFileFingerprint(filePath) {
  try {
    const stats = fs.statSync(filePath);
    return {
      mtime: stats.mtime.getTime(),
      size: stats.size
    };
  } catch {
    return null;
  }
}

// Get file hash (MD5)
function getFileHash(filePath) {
  try {
    const content = fs.readFileSync(filePath);
    return crypto.createHash('md5').update(content).digest('hex');
  } catch {
    return null;
  }
}

// Check if file actually changed
function hasFileChanged(filePath) {
  const oldFingerprint = fileFingerprints.get(filePath);
  const newFingerprint = getFileFingerprint(filePath);
  
  if (!newFingerprint) return false;
  if (!oldFingerprint) return true;
  
  // Fast path: check mtime and size first
  if (oldFingerprint.mtime === newFingerprint.mtime && 
      oldFingerprint.size === newFingerprint.size) {
    return false;
  }
  
  // Slow path: compute hash only if mtime/size changed
  const newHash = getFileHash(filePath);
  if (oldFingerprint.hash === newHash) {
    // Update mtime/size but keep same hash
    fileFingerprints.set(filePath, { ...newFingerprint, hash: newHash });
    return false;
  }
  
  // File actually changed
  fileFingerprints.set(filePath, { ...newFingerprint, hash: newHash });
  return true;
}

// Analysis function - uses smart analyzer logic
async function analyze() {
  const now = Date.now();
  
  // Rate limiting in real-time mode
  if (USE_REALTIME && now - lastAnalysisTime < MIN_ANALYSIS_INTERVAL) {
    pendingAnalysis = true;
    setTimeout(() => {
      if (pendingAnalysis) {
        pendingAnalysis = false;
        analyze();
      }
    }, MIN_ANALYSIS_INTERVAL - (now - lastAnalysisTime));
    return;
  }
  
  if (analysisInProgress) {
    pendingAnalysis = true;
    return;
  }
  
  analysisInProgress = true;
  lastAnalysisTime = now;
  checkCount++;
  const startTime = Date.now();
  
  process.stdout.write(`[${new Date().toLocaleTimeString()}] Analyzing... `);
  logger.info('Running analysis...', 'analyzer');
  
  try {
    // Run the smart analyzer and get its results
    const smartAnalyzerPath = path.join(__dirname, '..', 'dist', 'cli', 'analyze-smart.js');
    const smartResult = execSync(`node "${smartAnalyzerPath}"`, {
      cwd: projectPath,
      stdio: 'pipe',
      timeout: 30000,
      env: { ...process.env, OBSERVER_PROJECT_PATH: projectPath }
    }).toString();
    
    // Read the generated fixes.json from src/contracts
    const contractsDir = path.join(projectPath, 'src', 'contracts');
    const fixesPath = path.join(contractsDir, 'fixes.json');
    
    let smartData = { issues: [], buckets: [] };
    if (fs.existsSync(fixesPath)) {
      smartData = JSON.parse(fs.readFileSync(fixesPath, 'utf8'));
    }
    
    // Convert smart analyzer format to observer format
    const groups = [];
    let totalIssues = 0;
    
    if (smartData.buckets && smartData.buckets.length > 0) {
      smartData.buckets.forEach((bucket, index) => {
        if (bucket.issues && bucket.issues.length > 0) {
          groups.push({
            group: index + 1,
            title: bucket.name,
            why: bucket.description || 'Requires attention',
            fixes: bucket.issues.map(issue => ({
              file: `${issue.file}:${issue.line || 0}`,
              issue: issue.description,
              fix: issue.suggestion || 'Review and fix'
            }))
          });
          totalIssues += bucket.issues.length;
        }
      });
    }
    
    // Fallback: if no buckets, check for raw issues
    if (groups.length === 0 && smartData.issues && smartData.issues.length > 0) {
      groups.push({
        group: 1,
        title: 'Issues found',
        why: 'Requires attention',
        fixes: smartData.issues.slice(0, 20).map(issue => ({
          file: `${issue.file}:${issue.line || 0}`,
          issue: issue.description,
          fix: issue.suggestion || 'Review and fix'
        }))
      });
      totalIssues = smartData.issues.length;
    }
    
    // Write FIX_THIS.json
    const fixPath = path.join(observerDir, 'FIX_THIS.json');
    const data = {
      README: USE_REALTIME ? "Real-time updates. AI should read this file regularly." : "Auto-updates every 30 seconds.",
      generated: new Date().toISOString(),
      project: projectPath,
      fix_groups: groups,
      stats: {
        total_issues: totalIssues,
        groups_count: groups.length,
        mode: USE_REALTIME ? 'real-time' : 'interval',
        check_count: checkCount
      }
    };
    
    fs.writeFileSync(fixPath, JSON.stringify(data, null, 2));
    
    const duration = Date.now() - startTime;
    
    if (totalIssues > 0) {
      console.log(`âœ… Found ${totalIssues} issues (${groups.length} groups) [${duration}ms]`);
      logger.success(`Found ${totalIssues} issues in ${groups.length} groups`, 'analyzer', { duration, issueCount: totalIssues });
      groups.forEach(g => {
        console.log(`   â””â”€ Group ${g.group}: ${g.fixes.length} ${g.title.toLowerCase()}`);
      });
    } else {
      console.log(`âœ¨ No issues found! [${duration}ms]`);
      logger.success('No issues found!', 'analyzer', { duration });
    }
  } catch (error) {
    console.log(`âŒ Error: ${error.message}`);
    logger.error(`Analysis failed: ${error.message}`, 'analyzer');
  } finally {
    analysisInProgress = false;
    
    if (pendingAnalysis) {
      pendingAnalysis = false;
      setTimeout(analyze, 100);
    }
  }
}

// Debounced analysis
const debouncedAnalyze = debounce(analyze, DEBOUNCE_MS);

if (USE_REALTIME) {
  // Real-time mode with file watching
  console.log('ðŸ“Š LIVE STATUS:');
  console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
  
  // Set up file watcher
  const watcher = chokidar.watch(['src/**/*.{ts,tsx,js,jsx}', '.env', 'package.json'], {
    ignored: [
      '**/node_modules/**',
      '**/.git/**',
      '**/.observer/**',
      '**/dist/**',
      '**/build/**',
      '**/*.log'
    ],
    persistent: true,
    cwd: projectPath,
    ignoreInitial: true,
    awaitWriteFinish: {
      stabilityThreshold: 100,
      pollInterval: 100
    }
  });

  // Handle file changes
  watcher
    .on('add', filePath => {
      console.log(`ðŸ“ File added: ${filePath}`);
      logger.info(`File added: ${filePath}`, 'watcher');
      debouncedAnalyze();
    })
    .on('change', filePath => {
      if (hasFileChanged(path.join(projectPath, filePath))) {
        console.log(`ðŸ“ File changed: ${filePath}`);
        logger.info(`File changed: ${filePath}`, 'watcher');
        debouncedAnalyze();
      } else {
        process.stdout.write(`[${new Date().toLocaleTimeString()}] Skip: ${filePath} (unchanged)\r`);
        logger.debug(`File unchanged, skipping: ${filePath}`, 'watcher');
      }
    })
    .on('unlink', filePath => {
      console.log(`ðŸ—‘ï¸  File removed: ${filePath}`);
      logger.warning(`File removed: ${filePath}`, 'watcher');
      fileFingerprints.delete(filePath);
      debouncedAnalyze();
    })
    .on('error', error => {
      console.error(`âŒ Watcher error: ${error}`);
      logger.error(`Watcher error: ${error.message}`, 'watcher');
    })
    .on('ready', () => {
      console.log('âœ… Real-time monitoring active\n');
      logger.info(`Started real-time monitoring`, 'watcher');
      // Initial analysis
      analyze();
    });
} else {
  // Interval mode (default)
  console.log('ðŸ“Š LIVE STATUS:');
  console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
  console.log('');
  
  // Initial analysis
  analyze();
  
  // Re-analyze every 30 seconds
  setInterval(analyze, CHECK_INTERVAL);
  
  console.log(`â° Checking every ${CHECK_INTERVAL/1000} seconds`);
  console.log('ðŸ’¡ Tip: Use --realtime or -r flag for real-time file watching\n');
}

// Graceful shutdown
process.on('SIGINT', () => {
  console.log('\n\nðŸ‘‹ Shutting down observer...');
  logger.info('Observer shutdown', 'system');
  if (USE_REALTIME && global.watcher) {
    global.watcher.close();
  }
  process.exit(0);
});

// Keep process alive
process.stdin.resume();