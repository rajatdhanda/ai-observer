#!/usr/bin/env node

import { ProjectAnalyzer } from '../analyzer';
import * as path from 'path';
import * as fs from 'fs';

async function main() {
  const args = process.argv.slice(2);
  const projectPath = args[0] || process.cwd();
  
  const absolutePath = path.isAbsolute(projectPath) 
    ? projectPath 
    : path.resolve(process.cwd(), projectPath);
  
  console.log('ðŸš€ AI Observer - Project Analyzer');
  console.log('==================================');
  console.log(`ðŸ“ Project: ${absolutePath}`);
  console.log('');
  
  try {
    const analyzer = new ProjectAnalyzer();
    const analysis = await analyzer.analyze(absolutePath);
    
    console.log('\nðŸ“Š Analysis Summary:');
    console.log('-------------------');
    console.log(`âœ… Framework: ${analysis.framework.name} ${analysis.framework.version}`);
    console.log(`âœ… Type Definitions: ${analysis.types.totalCount}`);
    console.log(`âœ… Business Entities: ${analysis.entities.length}`);
    console.log(`âœ… Validation Rules: ${analysis.validationRules.length}`);
    console.log(`âœ… Data Flow Layers: ${analysis.dataFlow.layers.length}`);
    
    console.log('\nðŸ¢ Identified Entities:');
    analysis.entities.forEach(entity => {
      console.log(`  - ${entity.name} (${entity.properties.length} properties, ${entity.relationships.length} relationships)`);
    });
    
    console.log('\nðŸ”„ Data Flow:');
    analysis.dataFlow.layers.forEach(layer => {
      console.log(`  - ${layer.name}: ${layer.components.length} components`);
    });
    
    console.log('\nâš¡ Critical Paths:');
    analysis.dataFlow.criticalPaths.forEach(path => {
      console.log(`  - ${path.name} (${path.importance}): ${path.steps.join(' â†’ ')}`);
    });
    
    console.log('\nâœ… Validation Rules by Type:');
    const rulesByType = analysis.validationRules.reduce((acc, rule) => {
      acc[rule.type] = (acc[rule.type] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);
    
    Object.entries(rulesByType).forEach(([type, count]) => {
      console.log(`  - ${type}: ${count} rules`);
    });
    
    // Save detailed report
    const reportPath = path.join(process.cwd(), '.observer', 'analysis-report.md');
    const report = generateMarkdownReport(analysis);
    fs.writeFileSync(reportPath, report);
    console.log(`\nðŸ“„ Detailed report saved to: ${reportPath}`);
    
    console.log('\nâœ¨ Analysis complete! Run "npm run dashboard" to view in the UI.');
    
  } catch (error) {
    console.error('âŒ Analysis failed:', error);
    process.exit(1);
  }
}

function generateMarkdownReport(analysis: any): string {
  return `# AI Observer - Project Analysis Report

Generated: ${new Date().toISOString()}

## Project Information
- **Path**: ${analysis.projectPath}
- **Name**: ${analysis.projectName}
- **Framework**: ${analysis.framework.name} ${analysis.framework.version}
- **Type**: ${analysis.framework.type}

## Type System Analysis
- **Total Types**: ${analysis.types.totalCount}
- **Interfaces**: ${analysis.types.interfaces.length}
- **Type Aliases**: ${analysis.types.types.length}
- **Enums**: ${analysis.types.enums.length}

### Type Definitions
${analysis.types.interfaces.map((i: any) => `- **${i.name}** (${i.category}): ${i.properties?.length || 0} properties`).join('\\n')}

## Business Entities
${analysis.entities.map((e: any) => `
### ${e.name}
- **Type**: ${e.type}
- **Properties**: ${e.properties.length}
- **Relationships**: ${e.relationships.map((r: any) => `${r.type} ${r.entity}`).join(', ') || 'None'}
- **Operations**: ${e.operations.slice(0, 5).join(', ')}${e.operations.length > 5 ? '...' : ''}
`).join('')}

## Data Flow Architecture

### Layers
${analysis.dataFlow.layers.map((l: any) => `
- **${l.name}** (${l.type})
  - Components: ${l.components.slice(0, 10).join(', ')}${l.components.length > 10 ? '...' : ''}
`).join('')}

### Critical Paths
${analysis.dataFlow.criticalPaths.map((p: any) => `
- **${p.name}** (${p.importance})
  - Flow: ${p.steps.join(' â†’ ')}
`).join('')}

## Validation Rules

### Summary
- **Total Rules**: ${analysis.validationRules.length}
- **Auto-generated**: ${analysis.validationRules.filter((r: any) => r.autoGenerated).length}
- **Custom**: ${analysis.validationRules.filter((r: any) => !r.autoGenerated).length}

### Rules by Type
${Object.entries(analysis.validationRules.reduce((acc: any, rule: any) => {
  acc[rule.type] = (acc[rule.type] || 0) + 1;
  return acc;
}, {})).map(([type, count]) => `- **${type}**: ${count} rules`).join('\\n')}

### Rules by Severity
${Object.entries(analysis.validationRules.reduce((acc: any, rule: any) => {
  acc[rule.severity] = (acc[rule.severity] || 0) + 1;
  return acc;
}, {})).map(([severity, count]) => `- **${severity}**: ${count} rules`).join('\\n')}

## Recommendations

1. **Type Coverage**: Ensure all API endpoints have corresponding TypeScript interfaces
2. **Validation**: Implement the generated validation rules in your codebase
3. **Performance**: Review performance rules for optimization opportunities
4. **Security**: Address all security rules with 'error' severity immediately

---
*Generated by AI Observer*
`;
}

// Run the analyzer
main().catch(console.error);